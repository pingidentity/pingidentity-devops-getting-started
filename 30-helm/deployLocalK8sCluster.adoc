[#devops-deploy-a-local-kubernetes-cluster]
= Deploy a local Kubernetes Cluster

If you do not have access to a managed Kubernetes cluster you can deploy one on your local machine or or a virtual machine (VM). This document describes deploying a cluster with https://kind.sigs.k8s.io/[kind] and also for https://minikube.sigs.k8s.io/docs/[minikube].  Refer to the documentation of each product for additional information.

CAUTION: The instructions in this document are for testing and learning, and not intended for use in production.

NOTE: The processes outlined on this page will create either a Kubernetes in Docker (https://kind.sigs.k8s.io/[kind]) or a https://minikube.sigs.k8s.io/docs/[minikube] cluster.  In both cases, the cluster you get is very similar in functionality to the Docker Desktop implementation of Kubernetes.  However, a distinct advantage of both offerings is portability (not requiring Docker Desktop). As with the xref:get-started/getStartedExample.adoc[] procedure, the files provided will enable and deploy an ingress controller for communicating with the services in the cluster from your local environment.

CAUTION: To use the both examples below, you will need to ensure the Kubernetes feature of Docker Desktop is turned off, as it will conflict.

NOTE: This note applies only if using Docker as a backing for either solution. kind uses Docker by default, and it is also an option for minikube.  Docker on Linux is typically installed with root privileges and thus has access to the full resources of the machine. Docker Desktop for Mac and Windows provides a way to set the resources allocated to Docker. For this documentation, a Macbook Pro with the Apple silicon chipset was configured to use 6 CPUs and 12 GB Memory. You can adjust these values as necessary for your needs.

== Kind cluster

This section will cover the *kind* installation process. See the <<minikube-cluster>> section for minikube instructions.

=== Prerequisites

* https://docs.docker.com/get-docker/[docker]
* https://kubernetes.io/docs/tasks/tools/#kubectl[kubectl]
* ports 80 and 443 available on machine (optional but recommended for standard URLs)

NOTE: For this guide, Kubernetes 1.35.0 is used. It is deployed using version 0.31.0 of kind.

NOTE: At the time of the writing of this guide, Docker Desktop was version `4.46.0 (204649)`, running Docker Engine `28.4.0`.

NOTE: We install Traefik as the ingress controller to align with the Docker Desktop example.

[discrete#devops-install-and-confirm-the-cluster]
=== Install and confirm the cluster

. https://kind.sigs.k8s.io/docs/user/quick-start/#installation[Install kind] on your platform.
. Use the provided https://github.com/pingidentity/pingidentity-devops-getting-started/blob/master/20-kubernetes/kind.yaml[sample kind.yaml] file to create a kind cluster named `ping`. The config maps host ports 80/443 into the kind control-plane node and forwards them to Traefik NodePorts (30080/30443) so Traefik can serve standard URLs. From the root of your copy of the repository code, run the wrapper script:

[source,shell]
----
./20-kubernetes/create-kind-cluster.sh
----

NOTE: If the cluster already exists, the script deletes and recreates it.
+
Output:
+
image::kindDeployOutput.png[]

. Test cluster health by running the following commands:
+
[subs="+quotes"]
----
kubectl cluster-info

# Output - port will vary
Kubernetes control plane is running at https://127.0.0.1:64129
CoreDNS is running at https://127.0.0.1:64129/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

------------------

kubectl version

< output clipped >
Server Version: v1.35.0

------------------

kubectl get nodes

NAME                 STATUS   ROLES           AGE     VERSION
ping-control-plane   Ready    control-plane   55m     v1.35.0
----

[discrete#devops-enable-ingress]
=== Enable ingress with Traefik

. Install Traefik to handle Ingress resources:
+
[source,shell]
----
helm repo add traefik https://helm.traefik.io/traefik
helm repo update
helm upgrade --install traefik traefik/traefik \
  --namespace traefik --create-namespace \
  -f ./30-helm/ingress-traefik-values-kind.yaml
----
+
[WARNING]
:warning-caption: Demonstration Only
====
The values file used to configure Traefik is set to skip backend TLS verification so the Ping product consoles with self-signed certificates work via Traefik. Do not use this setting in production.
====

. Wait for Traefik to be ready:
+
[source,shell]
----
kubectl get pods --namespace traefik
----

Our examples will use the Helm release name `myping` and DNS domain suffix `pingdemo.example` for accessing applications. After the Ingress resources exist, add all expected hosts to `/etc/hosts`. When using host ports 80/443 (recommended), map the hosts to `127.0.0.1`:

[source,shell]
----
echo "127.0.0.1 myping-pingaccess-admin.pingdemo.example myping-pingaccess-engine.pingdemo.example myping-pingauthorize.pingdemo.example myping-pingauthorizepap.pingdemo.example myping-pingdataconsole.pingdemo.example myping-pingdelegator.pingdemo.example myping-pingdirectory.pingdemo.example myping-pingfederate-admin.pingdemo.example myping-pingfederate-engine.pingdemo.example myping-pingcentral.pingdemo.example" | sudo tee -a /etc/hosts > /dev/null
----

NOTE: If ports 80/443 are not available, remove the `extraPortMappings` from `kind.yaml` and use the Traefik NodePorts (30080/30443) directly.

Setup is complete. This local Kubernetes environment should be ready to deploy our xref:./deployHelm.adoc[Helm examples].

[discrete#devops-deploy-the-example-stack]
=== Deploy the Example Stack

. Create a namespace for running the stack in your Kubernetes cluster:
+
[subs="+quotes"]
----
# Create the namespace
kubectl create ns pinghelm

# Set the kubectl context to the namespace
kubectl config set-context --current --namespace=pinghelm

# Confirm
kubectl config view --minify | grep namespace:
----

. Create a secret in the namespace you will be using to run the example (pinghelm) using the `pingctl` utility. This secret will obtain an evaluation license based on your Ping DevOps username and key:

+
```sh
kubectl create secret generic devops-secret \
  --from-literal=PING_IDENTITY_DEVOPS_USER="$PING_IDENTITY_DEVOPS_USER" \
  --from-literal=PING_IDENTITY_DEVOPS_KEY="$PING_IDENTITY_DEVOPS_KEY" \
  --from-literal=PING_IDENTITY_ACCEPT_EULA="$PING_IDENTITY_ACCEPT_EULA" \
  --type=Opaque \
  --dry-run=client -o yaml | kubectl apply -f -
```

. To install the chart, go to your local `+"${PING_IDENTITY_DEVOPS_HOME}"/pingidentity-devops-getting-started/30-helm+` directory and run the command shown here.  In this example, the release (deployment into Kubernetes by Helm) is called `myping`, forming the prefix for all objects created. The `ingress-demo-kind.yaml` file configures the ingresses to use the Traefik ingress class:
+
``helm upgrade --install myping pingidentity/ping-devops -f everything.yaml -f ingress-demo-kind.yaml``

At this point, the flow will be the same as found in the xref:../get-started/getStartedExample.adoc[Getting Started Example] after the products are deployed using helm.  The URLs will be prefaced with `myping` rather than `demo`.

[discrete#devops-stop-the-cluster]
=== Stop the cluster

When you are finished, you can remove the cluster by running the following command, which removes the cluster completely.  You will be required to recreate the cluster to use `kind` again.

``kind delete cluster --name ping``

[[minikube-cluster]]
== Minikube cluster

In this section, a minikube installation with ingress is created.  Minikube is simpler than kind overall to configure, but ends up needing one step to configured a tunnel to the cluster that must be managed.
For this guide, the Docker driver will be used.  As with `kind` above, Kubernetes in Docker Desktop must be disabled.

[discrete#devops-prerequisites]
=== Prerequisites

* Container or virtual machine manager, such as: https://minikube.sigs.k8s.io/docs/drivers/docker/[Docker], https://minikube.sigs.k8s.io/docs/drivers/qemu/[QEMU], https://minikube.sigs.k8s.io/docs/drivers/hyperkit/[Hyperkit], https://minikube.sigs.k8s.io/docs/drivers/hyperv/[Hyper-V], https://minikube.sigs.k8s.io/docs/drivers/kvm2/[KVM], https://minikube.sigs.k8s.io/docs/drivers/parallels/[Parallels], https://minikube.sigs.k8s.io/docs/drivers/podman/[Podman], https://minikube.sigs.k8s.io/docs/drivers/virtualbox/[VirtualBox], or https://minikube.sigs.k8s.io/docs/drivers/vmware/[VMware Fusion/Workstation]
* https://kubernetes.io/docs/tasks/tools/#kubectl[kubectl]

NOTE: At the time of the writing of this guide, minikube was version `1.35.0`, which installs Kubernetes version `1.32.0`.

[discrete#devops-install-and-configure-minikube]
=== Install and configure minikube

. Install minikube for your platform.  See the product https://minikube.sigs.k8s.io/docs/start/[Get Started!] page for details.
. Configure the minikube resources and virtualization driver.  For example, the following options were used on an Apple Macbook Pro with Docker as the backing platform:
+
[subs="+quotes"]
----
minikube config set cpus 6
minikube config set driver docker
minikube config set memory 12g
----
+
NOTE: See https://minikube.sigs.k8s.io/docs/handbook/config/[the documentation] for more details on configuring minikube.

. Start the cluster.  Optionally you can include a profile flag (`--profile <name>`). Naming the cluster enables you to run multiple minikube clusters simultaneously.  If you use a profile name, you will need to include it on other minikube commands.
+
``minikube start --addons=ingress --kubernetes-version=v1.35.0``
+
Output:
+
image::minikubeStartOutput.png[]

. Test cluster health by running the following commands:
+
[subs="+quotes"]
----
kubectl cluster-info

# Output - Port will vary
Kubernetes control plane is running at https://127.0.0.1:51042
CoreDNS is running at https://127.0.0.1:51042/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

------------------

kubectl version

< output clipped >
Server Version: v1.35.0

------------------

kubectl get nodes

NAME       STATUS   ROLES           AGE    VERSION
minikube   Ready    control-plane   6m2s   v1.35.0
----

[discrete#devops-confirm-ingress]
=== Confirm ingress

. Confirm ingress is operational:
+
[subs="+quotes"]
----
kubectl get po -n ingress-nginx

NAME                                        READY   STATUS      RESTARTS   AGE
ingress-nginx-admission-create-hnmhx        0/1     Completed   0          6m14s
ingress-nginx-admission-patch-c4mct         0/1     Completed   1          6m14s
ingress-nginx-controller-56d7c84fd4-qqffn   1/1     Running     0          6m14s
----

. Deploy a test application
+
Use the following YAML file to create a Pod, Service and Ingress:
+
[subs="+quotes"]
----
apiVersion: v1
kind: Pod
metadata:
  name: example-web-pod
  labels:
    role: webserver
spec:
  containers:
    - name: web
      image: nginx
      ports:
        - name: web
          containerPort: 80
          protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: example-svc
spec:
  selector:
    role: webserver
  ports:
    - protocol: TCP
      port: 80
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-ingress
  namespace: default
  annotations:
    spec.ingressClassName: nginx
spec:
  rules:
    - host: example.k8s.local
      http:
        paths:
          - backend:
              service:
                name: example-svc
                port:
                  number: 80
            path: /
            pathType: Prefix
----
+
[subs="+quotes"]
----
kubectl apply -f test.yaml

pod/example-web-pod created
service/example-svc created
ingress.networking.k8s.io/example-ingress created
----

. Add an alias to the application to `/etc/hosts`.
+
``echo '127.0.0.1 example.k8s.local' | sudo tee -a /etc/hosts > /dev/null``

. Start a tunnel.  This command will tie up the terminal:
+
```sh
minikube tunnel

âœ…  Tunnel successfully started

ðŸ“Œ  NOTE: Please do not close this terminal as this process must stay alive for the tunnel to be accessible ...

â—  The service/ingress traefik requires privileged ports to be exposed: [80 443]
ðŸ”‘  sudo permission will be asked for it.
ðŸ”—  Starting tunnel for service traefik.
```
+
Open a browser to http://example.k8s.local.  You should see the Nginx landing page.

. Clean up tests
+
``kubectl delete -f test.yaml``

Our examples will use the Helm release name `myping` and DNS domain suffix `pingdemo.example` for accessing applications.  You can add all expected hosts to `/etc/hosts`:

```sh
echo '127.0.0.1 myping-pingaccess-admin.pingdemo.example myping-pingaccess-engine.pingdemo.example myping-pingauthorize.pingdemo.example myping-pingauthorizepap.pingdemo.example myping-pingdataconsole.pingdemo.example myping-pingdelegator.pingdemo.example myping-pingdirectory.pingdemo.example myping-pingfederate-admin.pingdemo.example myping-pingfederate-engine.pingdemo.example myping-pingcentral.pingdemo.example' | sudo tee -a /etc/hosts > /dev/null
```

Setup is complete.  This local Kubernetes environment should be ready to deploy our xref:./deployHelm.adoc[Helm examples]

=== Optional features

[discrete#devops-dashboard]
==== Dashboard

Minikube provides other add-ons that enhance your experience when working with your cluster.  One such add-on is the Dashboard, which can also provide metrics as follows:

``minikube addons enable metrics-server minikube dashboard``

==== Multiple nodes

If you have enough system resources, you can create a multi-node cluster.

For example, to start a 3-node cluster:

``minikube start --nodes 3``

CAUTION: Keep in mind that each node will receive the RAM/CPU/Disk configured for minikube.  Using the example configuration provided above, a 3-node cluster would need 36GB of RAM and 18 CPUs.

[discrete#devops-stop-the-cluster-2]
=== Stop the cluster

When you are finished, you can stop the cluster by running the following command.  Stopping retains the configuration and state of the cluster (namespaces, deployments, and so on) that will be restored when starting the cluster again.

``minikube stop``

You can also pause and unpause the cluster:

``minikube pause minikube unpause``

Alternatively, you can delete the minikube environment, which will do a reset and recreate everything the next time it is started.

``minikube delete``
